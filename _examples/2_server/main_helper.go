package main

import (
	"encoding/json"
	"github.com/codegangsta/negroni"
	"github.com/gorilla/pat"
	"github.com/gourd/service"
	"log"
	"net/http"
	"upper.io/db"
	"upper.io/db/sqlite"
)

// generic decoder type
type Decoder interface {
	Decode(v interface{}) error
}

// generic encoder type
type Encoder interface {
	Encode(v interface{}) error
}

// dummy rest binder
func Rest(r *pat.Router, base, noun, nounp string, s service.Service) {

	// define paths
	p := base + "/" + nounp
	ep := base + "/" + noun + "/{id}"

	// way to identify the key condition (for update, retrieve and delete)
	getKeyCond := func(r *http.Request) (cond service.Conds) {
		// TODO: generate the content of this function
		//       dynamically with gourd
		id := r.URL.Query().Get(":id") // will change
		return service.NewConds().Add("id", id)
	}

	// get request decoder
	getReqtDec := func(r *http.Request) Decoder {
		// TODO: get decoder according to request header
		//       or by middleware
		return json.NewDecoder(r.Body)
	}

	// get response encoder
	getRespEnc := func(w http.ResponseWriter, r *http.Request) Encoder {
		// TODO: get encoder according to request
		//       or by middleware
		return json.NewEncoder(w)
	}

	log.Printf("REST path: %s", p)

	// Create
	r.Post(p, func(w http.ResponseWriter, r *http.Request) {
		var err error

		// allocate entity
		e := s.AllocEntity()

		// assign encoder and decoder
		reqtDec := getReqtDec(r)
		respEnc := getRespEnc(w, r)

		// decode request
		err = reqtDec.Decode(e)
		if err != nil {
			log.Printf("Error JSON Unmarshal: %s", err.Error())
			respEnc.Encode(map[string]interface{}{
				"status":  "error",
				"code":    http.StatusBadRequest,
				"message": "Cannot decode request",
			})
			return
		}

		// create entity
		err = s.Create(nil, e)
		if err != nil {
			log.Printf("Error Creating %s: %s", noun, err.Error())
			respEnc.Encode(map[string]interface{}{
				"status":  "error",
				"code":    http.StatusBadRequest,
				"message": "Failed to create entity",
			})
			return
		}

		// encode response
		respEnc.Encode(map[string]interface{}{
			"status": "success",
			"code":   http.StatusOK,
			nounp:    []interface{}{e},
		})
	})

	// Retrieve single
	r.Get(ep, func(w http.ResponseWriter, r *http.Request) {
		var err error

		// allocate memory for variables
		el := s.AllocEntityList()

		// assign encoder and decoder
		respEnc := getRespEnc(w, r)

		// retrieve
		cond := getKeyCond(r)
		err = s.Search(cond, el)
		if err != nil {
			log.Printf("Error searching %s: %s", noun, err.Error())
			respEnc.Encode(map[string]interface{}{
				"status":  "error",
				"code":    http.StatusBadRequest,
				"message": "Failed to find entity",
			})
			return
		}

		// encode response
		if s.Len(el) == 0 {
			respEnc.Encode(map[string]interface{}{
				"status": "error",
				"code":   http.StatusNotFound,
			})
		} else {
			respEnc.Encode(map[string]interface{}{
				"status": "success",
				"code":   http.StatusOK,
				nounp:    el,
			})
		}
	})

	// TODO: Retrieve list

	// Update
	r.Put(ep, func(w http.ResponseWriter, r *http.Request) {
		var err error

		// allocate memory for variables
		e := s.AllocEntity()
		el := s.AllocEntityList()

		// assign encoder and decoder
		reqtDec := getReqtDec(r)
		respEnc := getRespEnc(w, r)

		// decode request
		err = reqtDec.Decode(e)
		if err != nil {
			log.Printf("Error JSON Unmarshal: %s", err.Error())
			respEnc.Encode(map[string]interface{}{
				"status":  "error",
				"code":    http.StatusBadRequest,
				"message": "Cannot decode request",
			})
			return
		}

		// find the content of the id
		cond := getKeyCond(r)
		err = s.Search(cond, el)
		if err != nil {
			log.Printf("Error searching %s: %s", noun, err.Error())
			respEnc.Encode(map[string]interface{}{
				"status":  "error",
				"code":    http.StatusBadRequest,
				"message": "Failed to find entity",
			})
			return
		}

		// update entity
		s.Update(cond, e)

		// encode response
		respEnc.Encode(map[string]interface{}{
			"status": "success",
			"code":   http.StatusOK,
			noun:     e,
		})
	})

	// Delete
	r.Delete(ep, func(w http.ResponseWriter, r *http.Request) {
		var err error

		// allocate memory for variables
		e := s.AllocEntity()
		el := s.AllocEntityList()

		// assign encoder and decoder
		respEnc := getRespEnc(w, r)

		// find the content of the id
		cond := getKeyCond(r)
		err = s.Search(cond, el)
		if err != nil {
			log.Printf("Error searching %s: %s", noun, err.Error())
			respEnc.Encode(map[string]interface{}{
				"status":  "error",
				"code":    http.StatusBadRequest,
				"message": "Failed to find entity",
			})
			return
		}

		// delete entity
		s.Delete(cond)

		// encode response
		respEnc.Encode(map[string]interface{}{
			"status": "success",
			"code":   http.StatusOK,
			noun:     e,
		})
	})

}

// getServer
//
// drafted gourd generated server
// will be generated by gourd CLI tool eventually
//
// Should also be a http.Handler that
// cound be tested by wrapping httptest sevrer
func gourdServer() (n *negroni.Negroni) {

	// define db
	db, err := db.Open(sqlite.Adapter, sqlite.ConnectionURL{
		Database: `./data/sqlite3.db`,
	})
	if err != nil {
		panic(err)
	}

	// create router specific / independent middleware
	//ep := &EncoderPrvdr{}
	//cp := &GorillaPatCondPrvdr{}
	//ap := &OAuth2Prvdr{}

	// provide services to auth provider
	//ap.UseServices(ClientService{db}, AuthService{db}, AccessService{db})

	// create router of the specific type
	r := pat.New()

	// create negroni middleware handler
	// with middlewares
	n = negroni.New()
	//n := negroni.New(
	//	negroni.Wrap(ep),
	//	negroni.Wrap(cp),
	//	negroni.Wrap(ap.Mid()))

	// add services rest to router
	Rest(r, "/api", "post", "posts", &PostService{db})
	Rest(r, "/api", "comment", "comments", &CommentService{db})

	// add oauth2 endpoints
	//AddOAuth2(r, "/oauth", ap)

	// use router in negroni
	n.UseHandler(r)

	return
}

// gourdMain
//
// gourd generated main
// feel free to copy the code and change
func gourdMain() {
	s := gourdServer()
	if s != nil {
		s.Run(":8080") // negroni specific
	}
}
